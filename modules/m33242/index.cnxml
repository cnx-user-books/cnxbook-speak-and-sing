<document xmlns="http://cnx.rice.edu/cnxml">

<title>Speak and Sing - Pitch Correction with PSOLA</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m33242</md:content-id>
  <md:title>Speak and Sing - Pitch Correction with PSOLA</md:title>
  <md:abstract>Explains the process used to pitch match words for use with the speak and sing.</md:abstract>
  <md:uuid>64ada675-7244-492c-8c16-1492772fd180</md:uuid>
</metadata>
<content>
  <section id="eip-248"><title>Introduction</title><para id="intro">
Pitch correction of the human voice is a common activity, with applications in music, entertainment, and law. It can be used to alter pitch to produce a more accurate or more pleasing tone in music, as well as add distortion effects. Several programs for entertainment use a form of pitch correction to modulate and distort a user's voice, allowing one to sound like a different gender or emulate a celebrity or other well-known voice. Voice distortion is also often required to protect the anonymity of individuals in the criminal justice system. However, it is the first of these applications that we are most interested in - producing a pleasing, tone-accurate song from a human voice.
</para></section><para id="delete_me"><title>Implementation</title>Pitch adjustment of a digitally-sampled audio file can be implemented simply using resampling. However, this completely alters the time scaling and cannot account for changes in the pitch and inflection of a voice over time, and thus cannot be considered. Instead, we shall use the more sophisticated Pitch-Synchronous Overlap Add algorithm, which allows us to modify pitch without compromised information or modifying the time scaling.</para><para id="eip-214">The pitch correction method involves the following basic steps:</para><list id="eip-512"><item>Detection of original pitch</item>
<item>Parsing of desired pitch frequencies</item>
<item>Correction of pitch</item></list><section id="eip-920"><title>Pitch Detection</title><para id="detect">First, the pitch of the original signal is determined. This is done using the FAST-Autocorrelation algorithm. This algorithm makes use of the fact that for a signal to have pitch, it must have a somewhat periodic nature, even if it is not a strictly periodic wave. The signal is divided into several small windows, each only a few milliseconds long and containing thousands of samples - enough to detect at least two periods and thus to determine the window's frequency.</para><para id="eip-775"><title>Finding periods</title>Each windowed segment is autocorrelated with itself to identify the length of the period. This is done by convolving the signal with itself with an increasing offset τ to obtain the autocorrelation function:</para><para id="eip-648">R(τ) = f(-τ) * f(τ)</para><para id="eip-119">For discrete, finite-length signals, it can be found as a sum of the product of the signal and its offset, in this form:</para><para id="eip-347">R(s) = Sum(x(n)x(n-s))</para><para id="eip-208">This autocorrelation acts as a match filter: the signal and its offset form will be the most alike when offset s is equal to one period. Thus, the autocorrelation function is at a minimum when the offset corresponds to the length of one period, in samples. </para><para id="eip-788"><title>Making it FAST</title>Autocorrelation in this fashion is very computationally expensive - one can expect that the algorithm will have to convolve two length-1000 signals several hundred times for each window to obtain the frequency from within the full possible range of frequencies for a human voice. To speed this up, we can make two assumptions:</para><list id="eip-764" list-type="enumerated" number-style="arabic"><item>The frequency of a window should be relatively close to that of the window before it</item>
<item>The first minimum corresponds to the period, so no further minima are needed</item></list><para id="eip-497">By starting at an offset relatively close to the previously found period length (perhaps 20 samples before where the period was found), we can eliminate a few hundred calculations per window. If a minimum is not found in this area, we simply broaden our range and try again. To reduce the computation time further, we also calculate the derivative dR(s)/ds to determine where the minimum occurs. Once we find the first minimum, we are finished with obtaining the frequency for this window, having shaved off up to 70% of our computation time.</para><para id="eip-563"><title>When we're done...</title>Once a frequency has been found for every window, a vector of frequencies (one for each window) is compiled and returned to the pitch correction handler function.</para><para id="eip-569"><figure id="exsignal"><media id="inputsignal" alt="Waveform of an input audio signal">
    <image mime-type="image/jpeg" src="../../media/pitch_signal.jpg"/>
  </media>
  
<caption>Waveform of an input audio signal (speech: "Mary had a little lamb...")
  </caption></figure>

<figure id="exdetect"><media id="pitchdetect" alt="Plot of frequency per window">
    <image mime-type="image/jpeg" src="../../media/pitch_detected.jpg"/>
  </media>
  
<caption>Detected frequencies of the signal above, one per window. Here it is easier to observe the spikes in frequency for parts of speech that may be spoken higher in pitch. If this input was sung rather than spoken, this plot would be much smoother and look closer to the desired frequency.
  </caption></figure>
</para></section><section id="eip-886"><title>Desired pitch</title><para id="eip-695">
The PSOLA pitch correction algorithm requires both an original pitch and a "target" pitch to achieve. If this were a fully-automated pitch-smoothing autotuner, the target pitch would be whatever "note" frequency was closest to the one observed. We on the other hand would like to bend the pitch to the specific frequency of the song, regardless of our starting point. To this end, we must generate a vector of desired frequencies.
</para>
<para id="eip-696">
Fortunately, thanks to our song interpretation earlier, we already have vectors of the pitch and length of each note in the song at hand. These vectors assume the following format:
</para><list id="eip-439" list-type="bulleted" bullet-style="open-circle"><item>Frequencies: fundamental frequency in Hz (one per note)</item>
<item>Durations: length in seconds independent of sampling frequency (one per note)</item></list><para id="eip-984">First, we generate a vector of frequencies for each sample at our defined sampling rate. This is as simple as producing a vector with a length equal to the total length of the song in seconds times the sampling frequency (thus, lengthN = sum(durations)*Fs). Then, for each note, we copy the frequency of that note over every sample in the vector for a range of the note's duration. This is most easily done using MatLab's "cumsum" function on the durations vector to make each note indexed by the cumulative time passed, and then multiply these by the sampling frequency to produce the index of each note in samples.</para><para id="eip-302">Now that we have the frequency for every sample, we can chop up this full-length signal into windows just as we did to the input signal. For each window's range, we simply take the mode of the frequencies in that range (given their short length, a window will never span more than two notes) and let that be the desired frequency for that window.</para><para id="eip-826"><figure id="exdesire"><media id="pitchdesired" alt="Plot of the desired pitch per window">
    <image mime-type="image/jpeg" src="../../media/pitch_desired.jpg"/>
  </media>
  
<caption>A plot of the desired frequency-per-window of "Mary Had a Little Lamb". The high and low notes are very clearly distinguishable.
  </caption></figure>
</para></section><section id="eip-167"><title>PSOLA</title><para id="eip-293">Now that we have our original and target frequencies, we can exercise the Pitch-Synchronous Overlap Add algorithm to attempt to correct the frequencies. Like autocorrelation, the PSOLA begins with a windowed, segmented signal. Because we have already determined pitches for a specific number of segments, the PSOLA computations will use the same segment length. This is easy to remember, but introduces some issues. For example, the PSOLA algorithm can make the finest pitch corrections with a greater number of smaller segments, allowing for smoother correction across the signal. But what would happen to the autocorrelation pitch detector if the segment was so small that a full period could not be obtained? A compromise must be made on a segment length which allows for optimal pitch detection and pitch correction, with guesswork as the only means of finding the "happy medium".</para><para id="eip-524"><title>Modifying pitch with Hanning windows</title>The signal we input to the PSOLA algorithm is already "windowed" into several overlapping segments. For each segment, the PSOLA creates Hanning windows (windows with a centralized hump-shaped distribution) centralized around the pitch-marks, or spikes in the amplitude. Once the segment is divided into overlapping windows, these windowed areas can be artificially pushed closer together for a shorter, higher-pitched signal, or farther apart for a longer, lower-pitched signal. The jumps between the beginning of each window is shortened or lengthened, and segments are duplicated or omitted where necessary. Unlike resampling, this change of pitch and duration does not compromise the underlying information.</para><para id="eip-115"><title>Smoothing it out with Overlap and Add</title>Once the pitch and duration of the signal have been adjusted, the segments are then recombined by overlapping and adding. This Overlap-Add method exploits the knowledge that a long discrete convolution can be simplified as the sum of several short convolutions, which is convenient for us since we already have a number of short segments. The Overlap-Add produces a signal which is the same duration as its input and has roughly the same spectrum as the input, but now contains bands of frequency close to our desired frequency and, when played back, shows the result of our desired pitch correction effect.</para><para id="eip-340"><emphasis effect="italics">The PSOLA algorithm described here is the Time-Domain PSOLA. Alternative PSOLA methods exist which depend on linear predictor coefficients rather than segmented waves. The TD-PSOLA is used for its simplicity in programming versus marginal increase in computational cost.</emphasis></para></section><section id="eip-617"><title>References</title><para id="ref1"><emphasis effect="italics">Gareth Middleton, "Pitch Detection Algorithms," Connexions, December 17, 2003, <link document="m11714" version="1.2">http://cnx.org/content/m11714/1.2/</link></emphasis>
</para>
<para id="ref2"><emphasis effect="italics">Lemmetty, Sami.  Review of Speech Synthesis Technology.  (Master’s Thesis: Helsinki University of Technology)  March 1999.  <link url="http://www.acoustics.hut.fi/~slemmett/dippa/thesis.pdf">http://www.acoustics.hut.fi/~slemmett/dippa/thesis.pdf</link></emphasis>
</para>
<para id="ref3"><emphasis effect="italics">Upperman, Gina. "Changing Pitch with PSOLA for Voice Conversion." Connexions. December 17, 2004. <link document="m12474" version="1.3">http://cnx.org/content/m12474/1.3/</link></emphasis>
</para></section>
</content>

</document>